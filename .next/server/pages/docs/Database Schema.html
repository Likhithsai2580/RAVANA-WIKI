<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charSet="utf-8"/><title>Database Schema<!-- --> - RAVANA AGI Documentation</title><meta name="description" content="Documentation for Database Schema"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/aa7d986e9c238cc1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/aa7d986e9c238cc1.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" defer="" data-nscript="beforeInteractive"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" defer="" data-nscript="beforeInteractive"></script><script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.0/dist/mermaid.min.js" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-64ad27b21261a9ce.js" defer=""></script><script src="/_next/static/chunks/main-eb143115b8bf2786.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a41459f5c0b49356.js" defer=""></script><script src="/_next/static/chunks/664-d254d21a6fe56bff.js" defer=""></script><script src="/_next/static/chunks/pages/docs/%5Bslug%5D-37d587d3c8e56222.js" defer=""></script><script src="/_next/static/QHWQNiRZOuW15nbk5-ngt/_buildManifest.js" defer=""></script><script src="/_next/static/QHWQNiRZOuW15nbk5-ngt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="min-h-screen flex flex-col"><div class="min-h-screen flex flex-col"><header class="bg-wiki-blue text-white p-4 shadow-md"><div class="container mx-auto flex justify-between items-center"><h1 class="text-2xl font-bold">RAVANA AGI Documentation</h1><nav><ul class="flex space-x-4"><li><a class="hover:underline" href="/">Home</a></li></ul></nav></div></header><div class="flex-grow container mx-auto p-4 flex flex-col md:flex-row gap-6"><div class="w-full md:w-64 flex-shrink-0"><nav class="w-full md:w-64 flex-shrink-0"><div class="bg-white rounded-lg shadow p-4 sticky top-4"><h3 class="font-bold text-lg mb-3">Documentation</h3><ul class="space-y-1"><li class="mb-3"><div class="font-semibold text-gray-700">A</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Action%20System">Action System</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/API%20Reference">API Reference</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Architecture%20&amp;%20Design">Architecture &amp; Design</a></li></ul></li><li class="mb-3"><div class="font-semibold text-gray-700">C</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Configuration">Configuration</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Conversational%20AI%20Communication%20Framework">Conversational AI Communication Framework</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Core%20System">Core System</a></li></ul></li><li class="mb-3"><div class="font-semibold text-gray-700">D</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 bg-wiki-blue text-white" href="/docs/Database%20Schema">Database Schema</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Decision-Making%20System">Decision-Making System</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Deployment%20&amp;%20Operations">Deployment &amp; Operations</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Development%20Guide">Development Guide</a></li></ul></li><li class="mb-3"><div class="font-semibold text-gray-700">E</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Emotional%20Intelligence">Emotional Intelligence</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Enhanced%20Snake%20Agent">Enhanced Snake Agent</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Enhanced%20Snake%20Agent%20Architecture">Enhanced Snake Agent Architecture</a></li></ul></li><li class="mb-3"><div class="font-semibold text-gray-700">G</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Graceful%20Shutdown">Graceful Shutdown</a></li></ul></li><li class="mb-3"><div class="font-semibold text-gray-700">L</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/LLM%20Integration">LLM Integration</a></li></ul></li><li class="mb-3"><div class="font-semibold text-gray-700">M</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Memory%20Systems">Memory Systems</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Multi-Modal%20Memory">Multi-Modal Memory</a></li></ul></li><li class="mb-3"><div class="font-semibold text-gray-700">P</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Project%20Overview">Project Overview</a></li></ul></li><li class="mb-3"><div class="font-semibold text-gray-700">S</div><ul class="ml-2 mt-1 space-y-1"><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Self-Improvement">Self-Improvement</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Services">Services</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Snake%20Agent%20Configuration">Snake Agent Configuration</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Specialized%20Modules-57f9b30b-b165-48d3-8e89-196940d26190">Specialized Modules</a></li><li><a class="block py-1 px-2 rounded hover:bg-gray-100 text-gray-600" href="/docs/Specialized%20Modules">Specialized Modules</a></li></ul></li></ul></div></nav></div><main class="flex-grow"><nav class="mb-4 text-sm"><ol class="list-none p-0 inline-flex"><li class="flex items-center"><a class="text-wiki-blue hover:underline" href="/">Home</a><svg class="fill-current w-3 h-3 mx-3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg></li><li class="flex items-center"><span class="text-gray-500">Database Schema</span></li></ol></nav><div class="flex flex-col md:flex-row gap-6"><article class="prose max-w-none bg-white p-6 rounded-lg shadow flex-grow"><h1>Database Schema</h1><div><h1>Database Schema</h1>
<h2>Update Summary</h2>
<p><strong>Changes Made</strong></p>
<ul>
<li>Added new entity definitions for VeryLongTermMemory, MemoryPattern, MemoryConsolidation, StrategicKnowledge, and related junction tables</li>
<li>Updated relationships and schema diagram to include new VLTM entities and many-to-many relationships</li>
<li>Added new section on Very Long-Term Memory System architecture</li>
<li>Updated indexing strategy to include new VLTM indexes</li>
<li>Enhanced data lifecycle policies to include VLTM retention policies</li>
<li>Added new section on strategic knowledge management</li>
</ul>
<h2>Table of Contents</h2>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#entity-definitions">Entity Definitions</a></li>
<li><a href="#very-long-term-memory-system">Very Long-Term Memory System</a></li>
<li><a href="#relationships-and-schema-diagram">Relationships and Schema Diagram</a></li>
<li><a href="#data-access-patterns-and-orm-usage">Data Access Patterns and ORM Usage</a></li>
<li><a href="#indexing-strategy-for-performance-critical-queries">Indexing Strategy for Performance-Critical Queries</a></li>
<li><a href="#data-lifecycle-policies-and-retention">Data Lifecycle Policies and Retention</a></li>
<li><a href="#data-security-encryption-and-backup-procedures">Data Security, Encryption, and Backup Procedures</a></li>
<li><a href="#migration-strategies-for-schema-evolution">Migration Strategies for Schema Evolution</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>
<h2>Introduction</h2>
<p>This document provides comprehensive documentation for the database schema used in the RAVANA AGI system. The schema is designed to support an autonomous artificial general intelligence system that processes information, makes decisions, reflects on its behavior, and evolves over time. The database stores various types of operational, emotional, and cognitive data that enable the system to maintain context, learn from experience, and generate intelligent responses. This documentation details all entities, their relationships, access patterns, performance considerations, and lifecycle management policies.</p>
<h2>Entity Definitions</h2>
<p>The database schema consists of several key entities that capture different aspects of the AGI's operation and cognition. Each entity is defined using SQLModel, which provides a Pythonic interface for database interactions.</p>
<h3>Article</h3>
<p>Stores information about news articles and other content sources that the system monitors.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>id</code>: int | None = Field(default=None, primary_key=True) - Unique identifier for the article</li>
<li><code>title</code>: str - Title of the article</li>
<li><code>link</code>: str - URL of the article</li>
<li><code>published</code>: str - Publication timestamp in ISO format</li>
<li><code>source</code>: str - Source of the article (e.g., CNN, BBC)</li>
<li><code>fetched_at</code>: str - Timestamp when the article was fetched by the system</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>id</code></li>
<li>Uniqueness is enforced at the application level based on the <code>link</code> field to prevent duplicate articles</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/models.py</a></li>
</ul>
<h3>Event</h3>
<p>Represents significant events detected by the system through analysis of articles and other inputs.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>id</code>: int | None = Field(default=None, primary_key=True) - Unique identifier for the event</li>
<li><code>timestamp</code>: str - Timestamp of the event in ISO format</li>
<li><code>description</code>: str - Natural language description of the event</li>
<li><code>keywords</code>: str - Comma-separated keywords associated with the event</li>
<li><code>cluster_id</code>: int - Identifier for the cluster to which this event belongs</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>id</code></li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/models.py</a></li>
</ul>
<h3>Summary</h3>
<p>Stores compressed knowledge and summaries generated by the system, serving as a mechanism for knowledge retention and deduplication.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>id</code>: int | None = Field(default=None, primary_key=True) - Unique identifier for the summary</li>
<li><code>timestamp</code>: str - Creation timestamp in ISO format</li>
<li><code>summary_text</code>: str - The actual summary content</li>
<li><code>source</code>: str | None = Field(default="unknown") - Source of the summary (e.g., system, user)</li>
<li><code>category</code>: str | None = Field(default="misc") - Category of the summary (e.g., compression, reflection)</li>
<li><code>content_hash</code>: str | None = Field(default=None) - SHA-256 hash of the summary text for deduplication</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>id</code></li>
<li>The <code>content_hash</code> field enables deduplication by allowing the system to check if a similar summary already exists</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/models.py</a></li>
</ul>
<h3>ActionLog</h3>
<p>Records all actions performed by the AGI system, providing an audit trail of its operations.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>id</code>: int | None = Field(default=None, primary_key=True) - Unique identifier for the log entry</li>
<li><code>timestamp</code>: str - Timestamp of the action in ISO format</li>
<li><code>action_name</code>: str - Name of the action performed</li>
<li><code>params</code>: str - JSON string containing the parameters passed to the action</li>
<li><code>status</code>: str - Status of the action ('success' or 'failure')</li>
<li><code>result</code>: str - JSON string containing the result of the action</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>id</code></li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/models.py</a></li>
</ul>
<h3>MoodLog</h3>
<p>Captures the emotional state of the AGI system at specific points in time.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>id</code>: int | None = Field(default=None, primary_key=True) - Unique identifier for the mood log entry</li>
<li><code>timestamp</code>: str - Timestamp of the mood recording in ISO format</li>
<li><code>mood_vector</code>: str - JSON string representing the mood vector (a multidimensional representation of emotional state)</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>id</code></li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/models.py</a></li>
</ul>
<h3>SituationLog</h3>
<p>Records situations generated by the system for decision-making and reflection purposes.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>id</code>: int | None = Field(default=None, primary_key=True) - Unique identifier for the situation log</li>
<li><code>timestamp</code>: str - Timestamp of the situation creation in ISO format</li>
<li><code>situation_type</code>: str - Type of situation (e.g., curiosity, reflection)</li>
<li><code>prompt</code>: str - The prompt that generated the situation</li>
<li><code>context</code>: str - JSON string containing additional context for the situation</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>id</code></li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/models.py</a></li>
</ul>
<h3>DecisionLog</h3>
<p>Stores decisions made by the AGI system in response to specific situations.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>id</code>: int | None = Field(default=None, primary_key=True) - Unique identifier for the decision log</li>
<li><code>timestamp</code>: str - Timestamp of the decision in ISO format</li>
<li><code>situation_id</code>: int | None = Field(default=None, foreign_key="situationlog.id") - Foreign key referencing the situation that prompted the decision</li>
<li><code>raw_response</code>: str - The raw response from the decision-making process</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>id</code></li>
<li>Foreign key relationship with <code>SituationLog</code> on the <code>situation_id</code> field</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/models.py</a></li>
</ul>
<h3>ExperimentLog</h3>
<p>Records experiments conducted by the AGI system to test hypotheses or explore new ideas.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>id</code>: int | None = Field(default=None, primary_key=True) - Unique identifier for the experiment log</li>
<li><code>timestamp</code>: str - Timestamp of the experiment in ISO format</li>
<li><code>hypothesis</code>: str - The hypothesis being tested</li>
<li><code>results</code>: str - JSON string containing the results of the experiment</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>id</code></li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/models.py</a></li>
</ul>
<h2>Very Long-Term Memory System</h2>
<p>The Very Long-Term Memory (VLTM) system has been enhanced with new entities and relationships to support advanced knowledge management and strategic reasoning.</p>
<h3>VeryLongTermMemory</h3>
<p>Core very long-term memory record that stores compressed cognitive content.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>memory_id</code>: str - Primary key, UUID identifier for the memory</li>
<li><code>memory_type</code>: MemoryType - Enum indicating the type of memory (strategic_knowledge, architectural_insight, etc.)</li>
<li><code>created_at</code>: datetime - Timestamp when the memory was created</li>
<li><code>last_accessed</code>: datetime - Timestamp of last access</li>
<li><code>promoted_at</code>: datetime - Timestamp when memory was promoted to long-term storage</li>
<li><code>access_count</code>: int - Number of times the memory has been accessed</li>
<li><code>importance_score</code>: float - Calculated importance score (0.0-1.0)</li>
<li><code>strategic_value</code>: float - Strategic value for long-term planning (0.0-1.0)</li>
<li><code>compressed_content</code>: str - JSON string of compressed memory data</li>
<li><code>metadata_info</code>: str - JSON string of metadata</li>
<li><code>source_session</code>: str - Identifier of the session that created the memory</li>
<li><code>related_memories</code>: str - JSON array of related memory IDs</li>
<li><code>retention_category</code>: str - Retention policy category</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>memory_id</code></li>
<li>Importance score and strategic value constrained between 0.0 and 1.0</li>
<li>JSON fields validated for proper format</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/vltm_data_models.py</a></li>
</ul>
<h3>MemoryPattern</h3>
<p>Patterns extracted from memories through analysis of memory content and relationships.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>pattern_id</code>: str - Primary key, UUID identifier for the pattern</li>
<li><code>pattern_type</code>: PatternType - Enum indicating the type of pattern (temporal, causal, behavioral, etc.)</li>
<li><code>pattern_description</code>: str - Natural language description of the pattern</li>
<li><code>confidence_score</code>: float - Confidence in pattern validity (0.0-1.0)</li>
<li><code>pattern_data</code>: str - JSON string of pattern-specific data</li>
<li><code>discovered_at</code>: datetime - Timestamp when the pattern was discovered</li>
<li><code>supporting_memories</code>: str - JSON array of memory IDs that support this pattern</li>
<li><code>validation_count</code>: int - Number of times the pattern has been validated</li>
<li><code>last_validated</code>: Optional[datetime] - Timestamp of last validation</li>
<li><code>source_memory_id</code>: Optional[str] - Foreign key to the source memory</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>pattern_id</code></li>
<li>Confidence score constrained between 0.0 and 1.0</li>
<li>JSON fields validated for proper format</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/vltm_data_models.py</a></li>
</ul>
<h3>MemoryConsolidation</h3>
<p>Records of memory consolidation processes that optimize storage and extract higher-level knowledge.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>consolidation_id</code>: str - Primary key, UUID identifier for the consolidation</li>
<li><code>consolidation_date</code>: datetime - Timestamp of the consolidation process</li>
<li><code>consolidation_type</code>: ConsolidationType - Enum indicating the type (daily, weekly, monthly, etc.)</li>
<li><code>memories_processed</code>: int - Number of memories processed in this consolidation</li>
<li><code>patterns_extracted</code>: int - Number of patterns extracted</li>
<li><code>compression_ratio</code>: float - Ratio of original size to compressed size</li>
<li><code>consolidation_results</code>: str - JSON string of consolidation results</li>
<li><code>processing_time_seconds</code>: float - Time taken to process the consolidation</li>
<li><code>success</code>: bool - Whether the consolidation was successful</li>
<li><code>error_message</code>: Optional[str] - Error message if consolidation failed</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>consolidation_id</code></li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/vltm_data_models.py</a></li>
</ul>
<h3>StrategicKnowledge</h3>
<p>High-level strategic knowledge derived from patterns and used for long-term planning.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>knowledge_id</code>: str - Primary key, UUID identifier for the knowledge</li>
<li><code>knowledge_domain</code>: str - Domain of the knowledge (e.g., architecture, performance, learning)</li>
<li><code>knowledge_summary</code>: str - Natural language summary of the knowledge</li>
<li><code>confidence_level</code>: float - Confidence in the knowledge (0.0-1.0)</li>
<li><code>last_updated</code>: datetime - Timestamp of last update</li>
<li><code>source_patterns</code>: str - JSON array of pattern IDs that contributed to this knowledge</li>
<li><code>knowledge_structure</code>: str - JSON string of structured knowledge representation</li>
<li><code>validation_score</code>: float - Score based on validation attempts (0.0-1.0)</li>
<li><code>application_count</code>: int - Number of times this knowledge has been applied</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>knowledge_id</code></li>
<li>Confidence level and validation score constrained between 0.0 and 1.0</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/vltm_data_models.py</a></li>
</ul>
<h3>ConsolidationPattern</h3>
<p>Junction table linking memory consolidations and patterns, enabling many-to-many relationships.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>consolidation_id</code>: str - Foreign key to memory_consolidations table, part of primary key</li>
<li><code>pattern_id</code>: str - Foreign key to memory_patterns table, part of primary key</li>
<li><code>extraction_confidence</code>: float - Confidence in the pattern extraction during consolidation</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Composite primary key on <code>consolidation_id</code> and <code>pattern_id</code></li>
<li>Foreign key relationships to memory_consolidations and memory_patterns tables</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/vltm_data_models.py</a></li>
</ul>
<h3>PatternStrategicKnowledge</h3>
<p>Junction table linking memory patterns and strategic knowledge, enabling many-to-many relationships.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>pattern_id</code>: str - Foreign key to memory_patterns table, part of primary key</li>
<li><code>knowledge_id</code>: str - Foreign key to strategic_knowledge table, part of primary key</li>
<li><code>contribution_weight</code>: float - Weight of the pattern's contribution to the strategic knowledge</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Composite primary key on <code>pattern_id</code> and <code>knowledge_id</code></li>
<li>Foreign key relationships to memory_patterns and strategic_knowledge tables</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/vltm_data_models.py</a></li>
</ul>
<h3>ConsolidationMetrics</h3>
<p>Performance metrics for consolidation processes.</p>
<p><strong>Fields:</strong></p>
<ul>
<li><code>metric_id</code>: str - Primary key, UUID identifier for the metric</li>
<li><code>consolidation_id</code>: str - Foreign key to memory_consolidations table</li>
<li><code>metric_name</code>: str - Name of the metric</li>
<li><code>metric_value</code>: float - Value of the metric</li>
<li><code>metric_unit</code>: str - Unit of measurement</li>
<li><code>timestamp</code>: datetime - Timestamp when the metric was recorded</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>Primary key on <code>metric_id</code></li>
<li>Foreign key relationship to memory_consolidations table</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/vltm_data_models.py</a></li>
</ul>
<h2>Relationships and Schema Diagram</h2>
<p>The database schema entities are related through foreign key relationships and conceptual associations that reflect the AGI system's cognitive processes.</p>
<p>``mermaid
erDiagram
SITUATIONLOG {
int id PK
string timestamp
string situation_type
string prompt
string context
}
DECISIONLOG {
int id PK
string timestamp
int situation_id FK
string raw_response
}
ARTICLE {
int id PK
string title
string link
string published
string source
string fetched_at
}
EVENT {
int id PK
string timestamp
string description
string keywords
int cluster_id
}
SUMMARY {
int id PK
string timestamp
string summary_text
string source
string category
string content_hash
}
ACTIONLOG {
int id PK
string timestamp
string action_name
string params
string status
string result
}
MOODLOG {
int id PK
string timestamp
string mood_vector
}
EXPERIMENTLOG {
int id PK
string timestamp
string hypothesis
string results
}
VERYLONGTERMMEMORY {
string memory_id PK
string memory_type
datetime created_at
datetime last_accessed
float importance_score
float strategic_value
string compressed_content
string metadata_info
}
MEMORYPATTERN {
string pattern_id PK
string pattern_type
string pattern_description
float confidence_score
datetime discovered_at
string source_memory_id FK
}
MEMORYCONSOLIDATION {
string consolidation_id PK
datetime consolidation_date
string consolidation_type
int memories_processed
int patterns_extracted
float compression_ratio
}
STRATEGICKNOWLEDGE {
string knowledge_id PK
string knowledge_domain
string knowledge_summary
float confidence_level
datetime last_updated
int application_count
}
CONSOLIDATIONPATTERN {
string consolidation_id PK, FK
string pattern_id PK, FK
float extraction_confidence
}
PATTERNSTRATEGICKNOWLEDGE {
string pattern_id PK, FK
string knowledge_id PK, FK
float contribution_weight
}
SITUATIONLOG ||--o{ DECISIONLOG : "has"
ARTICLE ||--o{ EVENT : "triggers"
SUMMARY ||--o{ EXPERIMENTLOG : "informs"
ACTIONLOG ||--o{ SITUATIONLOG : "generates"
MOODLOG ||--o{ SITUATIONLOG : "influences"
VERYLONGTERMMEMORY ||--o{ MEMORYPATTERN : "contains"
MEMORYPATTERN ||--o{ MEMORYCONSOLIDATION : "extracted_in"
MEMORYPATTERN ||--o{ STRATEGICKNOWLEDGE : "contributes_to"
MEMORYCONSOLIDATION ||--o{ CONSOLIDATIONPATTERN : "has"
CONSOLIDATIONPATTERN ||--o{ MEMORYPATTERN : "links"
MEMORYPATTERN ||--o{ PATTERNSTRATEGICKNOWLEDGE : "links"
PATTERNSTRATEGICKNOWLEDGE ||--o{ STRATEGICKNOWLEDGE : "links"</p>
<pre><code>
**Diagram sources**
- [core/vltm_data_models.py](file://c:\Users\ASUS\Documents\GitHub\RAVANA\core\vltm_data_models.py#L56-L198)
- [database/vltm_schema.sql](file://c:\Users\ASUS\Documents\GitHub\RAVANA\database\vltm_schema.sql#L96-L125)

**Section sources**
- [core/vltm_data_models.py](file://c:\Users\ASUS\Documents\GitHub\RAVANA\core\vltm_data_models.py#L56-L198)
- [database/vltm_schema.sql](file://c:\Users\ASUS\Documents\GitHub\RAVANA\database\vltm_schema.sql#L67-L125)

## Data Access Patterns and ORM Usage
The system uses SQLModel as an ORM (Object-Relational Mapper) to interact with the database, providing a clean, Pythonic interface for data operations.

### ORM Configuration
The database engine is configured in `engine.py` using SQLAlchemy's create_engine function with the database URL obtained from the configuration system.

```python
from sqlmodel import create_engine, SQLModel
from core.config import Config

engine = create_engine(Config.DATABASE_URL, echo=True)

def create_db_and_tables():
    SQLModel.metadata.create_all(engine)
</code></pre>
<p>The <code>create_db_and_tables()</code> function initializes the database schema by creating all tables defined in the SQLModel classes.</p>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/engine.py</a></li>
</ul>
<h3>Transaction Boundaries</h3>
<p>Data access follows a consistent pattern using context managers to ensure proper transaction boundaries and resource cleanup. The <code>DataService</code> class in <code>data_service.py</code> implements methods for saving various types of data with proper transaction management.</p>
<pre><code class="language-python">def save_action_log(self, action_name: str, params: dict, status: str, result: any):
    """Saves a record of an executed action to the database."""
    with Session(self.engine) as session:
        action_log = ActionLog(
            timestamp=datetime.utcnow().isoformat(),
            action_name=action_name,
            params=json.dumps(params),
            status=status,
            result=json.dumps(result)
        )
        session.add(action_log)
        session.commit()
</code></pre>
<p>Key characteristics of the data access pattern:</p>
<ul>
<li>Each operation uses a context manager (<code>with Session(...) as session</code>) to ensure the session is properly closed</li>
<li>Transactions are committed explicitly with <code>session.commit()</code></li>
<li>JSON serialization is used for complex data structures stored in text fields</li>
<li>Operations are atomic and follow the principle of least privilege</li>
</ul>
<h3>Data Service Implementation</h3>
<p>The <code>DataService</code> class provides a service layer interface for database operations, abstracting the underlying ORM details from the rest of the application.</p>
<p><strong>Key methods:</strong></p>
<ul>
<li><code>fetch_and_save_articles()</code>: Fetches articles from configured RSS feeds and saves new ones to the database</li>
<li><code>detect_and_save_events()</code>: Analyzes articles to detect significant events and saves them</li>
<li><code>save_action_log()</code>: Records system actions</li>
<li><code>save_mood_log()</code>: Records the system's emotional state</li>
<li><code>save_situation_log()</code>: Records generated situations</li>
<li><code>save_decision_log()</code>: Records decisions made by the system</li>
<li><code>save_experiment_log()</code>: Records experiments and their results</li>
</ul>
<p>The service layer ensures consistent data handling and provides a single point of control for database interactions.</p>
<p><strong>Section sources</strong></p>
<ul>
<li><a>services/data_service.py</a></li>
</ul>
<h2>Indexing Strategy for Performance-Critical Queries</h2>
<p>The system employs a multi-layered approach to optimize performance-critical queries, particularly for memory retrieval operations.</p>
<h3>ChromaDB for Semantic Memory Retrieval</h3>
<p>For performance-critical memory retrieval operations, the system uses ChromaDB, an embedding database optimized for semantic search. This is implemented in the <code>episodic_memory</code> module.</p>
<p><strong>Key features:</strong></p>
<ul>
<li>Uses sentence-transformers with the 'all-MiniLM-L6-v2' model to generate 384-dimensional embeddings</li>
<li>Stores embeddings in a persistent ChromaDB collection with automatic embedding generation</li>
<li>Supports similarity-based queries for retrieving relevant memories</li>
</ul>
<pre><code class="language-python">chroma_collection = chroma_client.get_or_create_collection(
    name=CHROMA_COLLECTION,
    embedding_function=sentence_transformer_ef
)
</code></pre>
<p><strong>Query process:</strong></p>
<ol>
<li>A query text is converted to an embedding vector</li>
<li>The system finds the nearest neighbors in the embedding space</li>
<li>Results are returned based on cosine similarity</li>
<li>A similarity threshold filters out irrelevant results</li>
</ol>
<p>The <code>get_relevant_memories_api</code> function implements this retrieval pattern:</p>
<pre><code class="language-python">def get_relevant_memories_api(request: QueryRequest):
    results = chroma_collection.query(
        query_texts=[request.query_text],
        n_results=request.top_n
    )
    
    # Convert distance to similarity and filter by threshold
    similarity = 1 - dist
    if similarity >= request.similarity_threshold:
        # Include in results
</code></pre>
<h3>VLTM Database Indexing</h3>
<p>The VLTM system implements comprehensive indexing strategies to optimize query performance for very long-term memory operations.</p>
<p><strong>Index types:</strong></p>
<ul>
<li><strong>B-tree indexes</strong>: On frequently queried scalar fields like timestamps, memory types, and confidence scores</li>
<li><strong>GIN indexes</strong>: On JSONB fields for efficient querying of structured data</li>
<li><strong>Text search indexes</strong>: Using tsvector for full-text search capabilities</li>
<li><strong>Composite indexes</strong>: On frequently queried field combinations</li>
</ul>
<p><strong>Key indexes:</strong></p>
<ul>
<li><code>idx_vltm_memory_type</code>: On memory_type for filtering by memory category</li>
<li><code>idx_vltm_created_at</code>: On created_at for time-based queries</li>
<li><code>idx_vltm_importance_score</code>: On importance_score for prioritizing important memories</li>
<li><code>idx_patterns_type</code>: On pattern_type for filtering by pattern category</li>
<li><code>idx_strategic_domain</code>: On knowledge_domain for domain-specific queries</li>
<li><code>idx_vltm_metadata_gin</code>: GIN index on metadata for efficient JSON querying</li>
<li><code>idx_patterns_description_text</code>: Text search index on pattern descriptions</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>database/vltm_schema.sql</a></li>
<li><a>modules/episodic_memory/memory.py</a></li>
<li><a>services/memory_service.py</a></li>
</ul>
<h2>Data Lifecycle Policies and Retention</h2>
<p>The system implements automated data lifecycle management through background tasks that handle retention, consolidation, and archival.</p>
<h3>Knowledge Compression</h3>
<p>The system runs a periodic knowledge compression task that summarizes recent interactions and creates higher-level abstractions.</p>
<p><strong>Configuration:</strong></p>
<ul>
<li>Frequency: Every 24 hours (86,400 seconds)</li>
<li>Triggered by: <code>knowledge_compression_task()</code> in the main system loop</li>
</ul>
<p><strong>Process:</strong></p>
<ol>
<li>Retrieves recent summaries from the database</li>
<li>Uses an LLM to compress and synthesize the information</li>
<li>Creates new <code>Summary</code> records with category "compression"</li>
<li>Uses content hashing to prevent duplication</li>
</ol>
<pre><code class="language-python">async def knowledge_compression_task(self):
    """Background task to compress knowledge every 24 hours."""
    while not self._shutdown.is_set():
        try:
            summary = await asyncio.to_thread(self.knowledge_service.compress_and_save_knowledge)
            logger.info(f"Compressed and saved knowledge summary.")
        except Exception as e:
            logger.error(f"Error in knowledge compression: {e}")

        try:
            await asyncio.sleep(86400)
        except asyncio.CancelledError:
            break
</code></pre>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/system.py</a></li>
<li><a>services/knowledge_service.py</a></li>
</ul>
<h3>Memory Consolidation</h3>
<p>The system performs periodic memory consolidation to optimize storage and retrieval efficiency.</p>
<p><strong>Configuration:</strong></p>
<ul>
<li>Frequency: Every 6 hours (21,600 seconds)</li>
<li>Triggered by: <code>memory_consolidation_task()</code> in the main system loop</li>
</ul>
<p><strong>Process:</strong></p>
<ol>
<li>Selects a batch of memories for consolidation</li>
<li>Uses an LLM to analyze, merge, deduplicate, and generalize memories</li>
<li>Creates consolidated memories with type 'long-term-consolidated'</li>
<li>Deletes the original, redundant memories</li>
</ol>
<p>The consolidation process follows these rules:</p>
<ul>
<li>Merge related memories into comprehensive statements</li>
<li>Remove duplicates, keeping the most detailed version</li>
<li>Generalize specific facts into broader categories</li>
<li>Never lose critical information</li>
<li>Never merge unrelated facts</li>
</ul>
<pre><code class="language-python">async def memory_consolidation_task(self):
    """Periodically consolidates memories to optimize retrieval and relevance."""
    while not self._shutdown.is_set():
        try:
            logger.info("Starting memory consolidation...")
            consolidation_result = await self.memory_service.consolidate_memories()
            logger.info(f"Memory consolidation finished. Report: {consolidation_result}")
        except Exception as e:
            logger.error(f"Error during memory consolidation: {e}", exc_info=True)

        try:
            await asyncio.sleep(21600)
        except asyncio.CancelledError:
            break
</code></pre>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/system.py</a></li>
<li><a>modules/episodic_memory/memory.py</a></li>
</ul>
<h3>VLTM Retention Policies</h3>
<p>The Very Long-Term Memory system implements configurable retention policies based on memory type and importance.</p>
<p><strong>Policy configuration:</strong></p>
<ul>
<li><strong>Strategic knowledge</strong>: Permanent retention, compression after 90 days</li>
<li><strong>Critical failures</strong>: Permanent retention, compression after 30 days</li>
<li><strong>Successful improvements</strong>: 2-year retention, compression after 180 days</li>
<li><strong>Code patterns</strong>: 1-year retention, compression after 90 days</li>
</ul>
<p><strong>Retention rules:</strong></p>
<ul>
<li>Memories are automatically compressed based on age and type</li>
<li>High-importance memories are retained permanently</li>
<li>Low-importance memories may be archived or deleted based on policy</li>
<li>Compression reduces storage footprint while preserving essential information</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/vltm_data_models.py</a></li>
<li><a>database/vltm_schema.sql</a></li>
</ul>
<h2>Data Security, Encryption, and Backup Procedures</h2>
<p>The system's approach to data security, encryption, and backup is primarily defined by its configuration and deployment environment.</p>
<h3>Database Configuration</h3>
<p>The database URL is configured through environment variables, allowing for flexible deployment configurations.</p>
<pre><code class="language-python">class Config:
    DATABASE_URL = os.environ.get("DATABASE_URL", "sqlite:///ravana_agi.db")
</code></pre>
<p><strong>Default configuration:</strong></p>
<ul>
<li>SQLite database file named <code>ravana_agi.db</code></li>
<li>Stored in the working directory</li>
<li>No built-in encryption at rest</li>
</ul>
<p><strong>Security implications:</strong></p>
<ul>
<li>The default SQLite configuration provides no encryption for data at rest</li>
<li>Production deployments should use environment variables to specify a database URL with appropriate security features</li>
<li>Supported databases include PostgreSQL, MySQL, and others that can provide encryption at rest</li>
</ul>
<h3>Data Protection Measures</h3>
<p>The system implements several data protection measures:</p>
<p><strong>Deduplication with hashing:</strong></p>
<ul>
<li>Uses SHA-256 hashing to identify duplicate content</li>
<li>Hashes are stored in the <code>content_hash</code> field of the <code>Summary</code> table</li>
<li>Prevents redundant storage of identical information</li>
</ul>
<pre><code class="language-python">content_hash = hashlib.sha256(content.encode('utf-8')).hexdigest()
</code></pre>
<p><strong>No explicit backup procedures:</strong></p>
<ul>
<li>The codebase does not contain explicit backup procedures</li>
<li>Backup strategy would depend on the underlying database system and deployment environment</li>
<li>For SQLite, backup would involve copying the database file</li>
<li>For server-based databases, standard database backup procedures would apply</li>
</ul>
<p><strong>Section sources</strong></p>
<ul>
<li><a>core/config.py</a></li>
<li><a>services/knowledge_service.py</a></li>
</ul>
<h2>Migration Strategies for Schema Evolution</h2>
<p>The system's architecture suggests several approaches for handling schema evolution, though explicit migration tools are not implemented in the current codebase.</p>
<h3>Current State</h3>
<p>The system uses SQLModel's <code>create_all()</code> method to create tables, which only creates missing tables but does not handle schema changes to existing tables.</p>
<pre><code class="language-python">def create_db_and_tables():
    SQLModel.metadata.create_all(engine)
</code></pre>
<p>This approach has limitations:</p>
<ul>
<li>Does not modify existing columns</li>
<li>Does not add constraints to existing tables</li>
<li>Does not handle data migration between schema versions</li>
<li>Risk of data loss or corruption during schema changes</li>
</ul>
<h3>Recommended Migration Strategy</h3>
<p>For production use, the following migration strategy is recommended:</p>
<p><strong>1. Use Alembic for database migrations:</strong></p>
<ul>
<li>Alembic is the standard migration tool for SQLAlchemy (which SQLModel is built upon)</li>
<li>Provides versioned migration scripts</li>
<li>Supports both automated and manual migration generation</li>
<li>Handles forward and backward migrations</li>
</ul>
<p><strong>2. Migration process:</strong></p>
<ul>
<li>Create a new migration script for each schema change</li>
<li>Include data migration logic when necessary</li>
<li>Test migrations on a copy of production data</li>
<li>Apply migrations in a controlled manner</li>
</ul>
<p><strong>3. Example migration workflow:</strong></p>
<pre><code class="language-bash"># Generate migration
alembic revision --autogenerate -m "Add mood intensity field"

# Review and edit migration script
# Apply migration
alembic upgrade head
</code></pre>
<p><strong>4. Zero-downtime considerations:</strong></p>
<ul>
<li>Design schema changes to be backward compatible</li>
<li>Use additive changes when possible (adding columns, not removing)</li>
<li>Implement feature flags for new functionality</li>
<li>Deploy schema changes separately from application changes when possible</li>
</ul>
<p><strong>5. Data migration best practices:</strong></p>
<ul>
<li>Always backup data before migrations</li>
<li>Test migrations on representative data sets</li>
<li>Monitor application behavior after migrations</li>
<li>Have a rollback plan for each migration</li>
</ul>
<p>While the current codebase does not implement a formal migration system, adopting Alembic or a similar tool would provide a robust solution for schema evolution.</p>
<h2>Conclusion</h2>
<p>The RAVANA AGI system employs a comprehensive database schema designed to support an autonomous artificial intelligence that can process information, make decisions, and evolve over time. The schema captures various aspects of the system's operation, including external inputs (articles), internal states (mood logs), cognitive processes (situations, decisions), and learning mechanisms (summaries, experiments).</p>
<p>Key strengths of the current implementation include:</p>
<ul>
<li>Clean separation of concerns through well-defined entities</li>
<li>Effective use of JSON fields for flexible data storage</li>
<li>Integration of semantic search through ChromaDB for performance-critical memory retrieval</li>
<li>Automated data lifecycle management through periodic compression and consolidation</li>
<li>Enhanced Very Long-Term Memory system with many-to-many relationships between consolidations, patterns, and strategic knowledge</li>
</ul>
<p>Areas for improvement include:</p>
<ul>
<li>Implementing a formal database migration system like Alembic</li>
<li>Enhancing data security with encryption at rest</li>
<li>Establishing explicit backup procedures</li>
<li>Potentially adding database indexes on frequently queried fields</li>
</ul>
<p>The system's architecture demonstrates a sophisticated approach to AGI data management, balancing structured storage with flexible, semantic retrieval mechanisms to support intelligent behavior.</p>
<p><strong>Referenced Files in This Document</strong></p>
<ul>
<li><a>database/models.py</a></li>
<li><a>database/engine.py</a></li>
<li><a>services/data_service.py</a></li>
<li><a>services/knowledge_service.py</a></li>
<li><a>core/config.py</a></li>
<li><a>modules/episodic_memory/memory.py</a></li>
<li><a>services/memory_service.py</a></li>
<li><a>modules/knowledge_compression/compressed_memory.py</a></li>
<li><a>core/vltm_data_models.py</a> - <em>Updated in recent commit</em></li>
<li><a>database/vltm_schema.sql</a> - <em>Updated in recent commit</em></li>
</ul>
</div></article><div class="w-full md:w-64 flex-shrink-0"></div></div></main></div><footer class="bg-wiki-dark text-white p-4"><div class="container mx-auto text-center"><p>© <!-- -->2025<!-- --> RAVANA AGI System Documentation</p></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"doc":{"slug":"Database Schema","title":"Database Schema","content":"\u003ch1\u003eDatabase Schema\u003c/h1\u003e\n\u003ch2\u003eUpdate Summary\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eChanges Made\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAdded new entity definitions for VeryLongTermMemory, MemoryPattern, MemoryConsolidation, StrategicKnowledge, and related junction tables\u003c/li\u003e\n\u003cli\u003eUpdated relationships and schema diagram to include new VLTM entities and many-to-many relationships\u003c/li\u003e\n\u003cli\u003eAdded new section on Very Long-Term Memory System architecture\u003c/li\u003e\n\u003cli\u003eUpdated indexing strategy to include new VLTM indexes\u003c/li\u003e\n\u003cli\u003eEnhanced data lifecycle policies to include VLTM retention policies\u003c/li\u003e\n\u003cli\u003eAdded new section on strategic knowledge management\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eTable of Contents\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#introduction\"\u003eIntroduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#entity-definitions\"\u003eEntity Definitions\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#very-long-term-memory-system\"\u003eVery Long-Term Memory System\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#relationships-and-schema-diagram\"\u003eRelationships and Schema Diagram\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#data-access-patterns-and-orm-usage\"\u003eData Access Patterns and ORM Usage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#indexing-strategy-for-performance-critical-queries\"\u003eIndexing Strategy for Performance-Critical Queries\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#data-lifecycle-policies-and-retention\"\u003eData Lifecycle Policies and Retention\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#data-security-encryption-and-backup-procedures\"\u003eData Security, Encryption, and Backup Procedures\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#migration-strategies-for-schema-evolution\"\u003eMigration Strategies for Schema Evolution\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis document provides comprehensive documentation for the database schema used in the RAVANA AGI system. The schema is designed to support an autonomous artificial general intelligence system that processes information, makes decisions, reflects on its behavior, and evolves over time. The database stores various types of operational, emotional, and cognitive data that enable the system to maintain context, learn from experience, and generate intelligent responses. This documentation details all entities, their relationships, access patterns, performance considerations, and lifecycle management policies.\u003c/p\u003e\n\u003ch2\u003eEntity Definitions\u003c/h2\u003e\n\u003cp\u003eThe database schema consists of several key entities that capture different aspects of the AGI's operation and cognition. Each entity is defined using SQLModel, which provides a Pythonic interface for database interactions.\u003c/p\u003e\n\u003ch3\u003eArticle\u003c/h3\u003e\n\u003cp\u003eStores information about news articles and other content sources that the system monitors.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e: int | None = Field(default=None, primary_key=True) - Unique identifier for the article\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etitle\u003c/code\u003e: str - Title of the article\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elink\u003c/code\u003e: str - URL of the article\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epublished\u003c/code\u003e: str - Publication timestamp in ISO format\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esource\u003c/code\u003e: str - Source of the article (e.g., CNN, BBC)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efetched_at\u003c/code\u003e: str - Timestamp when the article was fetched by the system\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eUniqueness is enforced at the application level based on the \u003ccode\u003elink\u003c/code\u003e field to prevent duplicate articles\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eEvent\u003c/h3\u003e\n\u003cp\u003eRepresents significant events detected by the system through analysis of articles and other inputs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e: int | None = Field(default=None, primary_key=True) - Unique identifier for the event\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp\u003c/code\u003e: str - Timestamp of the event in ISO format\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edescription\u003c/code\u003e: str - Natural language description of the event\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekeywords\u003c/code\u003e: str - Comma-separated keywords associated with the event\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecluster_id\u003c/code\u003e: int - Identifier for the cluster to which this event belongs\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eSummary\u003c/h3\u003e\n\u003cp\u003eStores compressed knowledge and summaries generated by the system, serving as a mechanism for knowledge retention and deduplication.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e: int | None = Field(default=None, primary_key=True) - Unique identifier for the summary\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp\u003c/code\u003e: str - Creation timestamp in ISO format\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esummary_text\u003c/code\u003e: str - The actual summary content\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esource\u003c/code\u003e: str | None = Field(default=\"unknown\") - Source of the summary (e.g., system, user)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecategory\u003c/code\u003e: str | None = Field(default=\"misc\") - Category of the summary (e.g., compression, reflection)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtent_hash\u003c/code\u003e: str | None = Field(default=None) - SHA-256 hash of the summary text for deduplication\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003econtent_hash\u003c/code\u003e field enables deduplication by allowing the system to check if a similar summary already exists\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eActionLog\u003c/h3\u003e\n\u003cp\u003eRecords all actions performed by the AGI system, providing an audit trail of its operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e: int | None = Field(default=None, primary_key=True) - Unique identifier for the log entry\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp\u003c/code\u003e: str - Timestamp of the action in ISO format\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaction_name\u003c/code\u003e: str - Name of the action performed\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparams\u003c/code\u003e: str - JSON string containing the parameters passed to the action\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estatus\u003c/code\u003e: str - Status of the action ('success' or 'failure')\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eresult\u003c/code\u003e: str - JSON string containing the result of the action\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eMoodLog\u003c/h3\u003e\n\u003cp\u003eCaptures the emotional state of the AGI system at specific points in time.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e: int | None = Field(default=None, primary_key=True) - Unique identifier for the mood log entry\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp\u003c/code\u003e: str - Timestamp of the mood recording in ISO format\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emood_vector\u003c/code\u003e: str - JSON string representing the mood vector (a multidimensional representation of emotional state)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eSituationLog\u003c/h3\u003e\n\u003cp\u003eRecords situations generated by the system for decision-making and reflection purposes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e: int | None = Field(default=None, primary_key=True) - Unique identifier for the situation log\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp\u003c/code\u003e: str - Timestamp of the situation creation in ISO format\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esituation_type\u003c/code\u003e: str - Type of situation (e.g., curiosity, reflection)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eprompt\u003c/code\u003e: str - The prompt that generated the situation\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtext\u003c/code\u003e: str - JSON string containing additional context for the situation\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDecisionLog\u003c/h3\u003e\n\u003cp\u003eStores decisions made by the AGI system in response to specific situations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e: int | None = Field(default=None, primary_key=True) - Unique identifier for the decision log\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp\u003c/code\u003e: str - Timestamp of the decision in ISO format\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esituation_id\u003c/code\u003e: int | None = Field(default=None, foreign_key=\"situationlog.id\") - Foreign key referencing the situation that prompted the decision\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eraw_response\u003c/code\u003e: str - The raw response from the decision-making process\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eForeign key relationship with \u003ccode\u003eSituationLog\u003c/code\u003e on the \u003ccode\u003esituation_id\u003c/code\u003e field\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExperimentLog\u003c/h3\u003e\n\u003cp\u003eRecords experiments conducted by the AGI system to test hypotheses or explore new ideas.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eid\u003c/code\u003e: int | None = Field(default=None, primary_key=True) - Unique identifier for the experiment log\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp\u003c/code\u003e: str - Timestamp of the experiment in ISO format\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehypothesis\u003c/code\u003e: str - The hypothesis being tested\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eresults\u003c/code\u003e: str - JSON string containing the results of the experiment\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eVery Long-Term Memory System\u003c/h2\u003e\n\u003cp\u003eThe Very Long-Term Memory (VLTM) system has been enhanced with new entities and relationships to support advanced knowledge management and strategic reasoning.\u003c/p\u003e\n\u003ch3\u003eVeryLongTermMemory\u003c/h3\u003e\n\u003cp\u003eCore very long-term memory record that stores compressed cognitive content.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ememory_id\u003c/code\u003e: str - Primary key, UUID identifier for the memory\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ememory_type\u003c/code\u003e: MemoryType - Enum indicating the type of memory (strategic_knowledge, architectural_insight, etc.)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecreated_at\u003c/code\u003e: datetime - Timestamp when the memory was created\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elast_accessed\u003c/code\u003e: datetime - Timestamp of last access\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epromoted_at\u003c/code\u003e: datetime - Timestamp when memory was promoted to long-term storage\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaccess_count\u003c/code\u003e: int - Number of times the memory has been accessed\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eimportance_score\u003c/code\u003e: float - Calculated importance score (0.0-1.0)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estrategic_value\u003c/code\u003e: float - Strategic value for long-term planning (0.0-1.0)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecompressed_content\u003c/code\u003e: str - JSON string of compressed memory data\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emetadata_info\u003c/code\u003e: str - JSON string of metadata\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esource_session\u003c/code\u003e: str - Identifier of the session that created the memory\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erelated_memories\u003c/code\u003e: str - JSON array of related memory IDs\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eretention_category\u003c/code\u003e: str - Retention policy category\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003ememory_id\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eImportance score and strategic value constrained between 0.0 and 1.0\u003c/li\u003e\n\u003cli\u003eJSON fields validated for proper format\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eMemoryPattern\u003c/h3\u003e\n\u003cp\u003ePatterns extracted from memories through analysis of memory content and relationships.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epattern_id\u003c/code\u003e: str - Primary key, UUID identifier for the pattern\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epattern_type\u003c/code\u003e: PatternType - Enum indicating the type of pattern (temporal, causal, behavioral, etc.)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epattern_description\u003c/code\u003e: str - Natural language description of the pattern\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econfidence_score\u003c/code\u003e: float - Confidence in pattern validity (0.0-1.0)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epattern_data\u003c/code\u003e: str - JSON string of pattern-specific data\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ediscovered_at\u003c/code\u003e: datetime - Timestamp when the pattern was discovered\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esupporting_memories\u003c/code\u003e: str - JSON array of memory IDs that support this pattern\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalidation_count\u003c/code\u003e: int - Number of times the pattern has been validated\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elast_validated\u003c/code\u003e: Optional[datetime] - Timestamp of last validation\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esource_memory_id\u003c/code\u003e: Optional[str] - Foreign key to the source memory\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003epattern_id\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eConfidence score constrained between 0.0 and 1.0\u003c/li\u003e\n\u003cli\u003eJSON fields validated for proper format\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eMemoryConsolidation\u003c/h3\u003e\n\u003cp\u003eRecords of memory consolidation processes that optimize storage and extract higher-level knowledge.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econsolidation_id\u003c/code\u003e: str - Primary key, UUID identifier for the consolidation\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econsolidation_date\u003c/code\u003e: datetime - Timestamp of the consolidation process\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econsolidation_type\u003c/code\u003e: ConsolidationType - Enum indicating the type (daily, weekly, monthly, etc.)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ememories_processed\u003c/code\u003e: int - Number of memories processed in this consolidation\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epatterns_extracted\u003c/code\u003e: int - Number of patterns extracted\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecompression_ratio\u003c/code\u003e: float - Ratio of original size to compressed size\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econsolidation_results\u003c/code\u003e: str - JSON string of consolidation results\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eprocessing_time_seconds\u003c/code\u003e: float - Time taken to process the consolidation\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esuccess\u003c/code\u003e: bool - Whether the consolidation was successful\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eerror_message\u003c/code\u003e: Optional[str] - Error message if consolidation failed\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003econsolidation_id\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStrategicKnowledge\u003c/h3\u003e\n\u003cp\u003eHigh-level strategic knowledge derived from patterns and used for long-term planning.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eknowledge_id\u003c/code\u003e: str - Primary key, UUID identifier for the knowledge\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eknowledge_domain\u003c/code\u003e: str - Domain of the knowledge (e.g., architecture, performance, learning)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eknowledge_summary\u003c/code\u003e: str - Natural language summary of the knowledge\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econfidence_level\u003c/code\u003e: float - Confidence in the knowledge (0.0-1.0)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elast_updated\u003c/code\u003e: datetime - Timestamp of last update\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esource_patterns\u003c/code\u003e: str - JSON array of pattern IDs that contributed to this knowledge\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eknowledge_structure\u003c/code\u003e: str - JSON string of structured knowledge representation\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalidation_score\u003c/code\u003e: float - Score based on validation attempts (0.0-1.0)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eapplication_count\u003c/code\u003e: int - Number of times this knowledge has been applied\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003eknowledge_id\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eConfidence level and validation score constrained between 0.0 and 1.0\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConsolidationPattern\u003c/h3\u003e\n\u003cp\u003eJunction table linking memory consolidations and patterns, enabling many-to-many relationships.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econsolidation_id\u003c/code\u003e: str - Foreign key to memory_consolidations table, part of primary key\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epattern_id\u003c/code\u003e: str - Foreign key to memory_patterns table, part of primary key\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eextraction_confidence\u003c/code\u003e: float - Confidence in the pattern extraction during consolidation\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eComposite primary key on \u003ccode\u003econsolidation_id\u003c/code\u003e and \u003ccode\u003epattern_id\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eForeign key relationships to memory_consolidations and memory_patterns tables\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ePatternStrategicKnowledge\u003c/h3\u003e\n\u003cp\u003eJunction table linking memory patterns and strategic knowledge, enabling many-to-many relationships.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epattern_id\u003c/code\u003e: str - Foreign key to memory_patterns table, part of primary key\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eknowledge_id\u003c/code\u003e: str - Foreign key to strategic_knowledge table, part of primary key\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtribution_weight\u003c/code\u003e: float - Weight of the pattern's contribution to the strategic knowledge\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eComposite primary key on \u003ccode\u003epattern_id\u003c/code\u003e and \u003ccode\u003eknowledge_id\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eForeign key relationships to memory_patterns and strategic_knowledge tables\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConsolidationMetrics\u003c/h3\u003e\n\u003cp\u003ePerformance metrics for consolidation processes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFields:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emetric_id\u003c/code\u003e: str - Primary key, UUID identifier for the metric\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econsolidation_id\u003c/code\u003e: str - Foreign key to memory_consolidations table\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emetric_name\u003c/code\u003e: str - Name of the metric\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emetric_value\u003c/code\u003e: float - Value of the metric\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emetric_unit\u003c/code\u003e: str - Unit of measurement\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimestamp\u003c/code\u003e: datetime - Timestamp when the metric was recorded\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eConstraints:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrimary key on \u003ccode\u003emetric_id\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eForeign key relationship to memory_consolidations table\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eRelationships and Schema Diagram\u003c/h2\u003e\n\u003cp\u003eThe database schema entities are related through foreign key relationships and conceptual associations that reflect the AGI system's cognitive processes.\u003c/p\u003e\n\u003cp\u003e``mermaid\nerDiagram\nSITUATIONLOG {\nint id PK\nstring timestamp\nstring situation_type\nstring prompt\nstring context\n}\nDECISIONLOG {\nint id PK\nstring timestamp\nint situation_id FK\nstring raw_response\n}\nARTICLE {\nint id PK\nstring title\nstring link\nstring published\nstring source\nstring fetched_at\n}\nEVENT {\nint id PK\nstring timestamp\nstring description\nstring keywords\nint cluster_id\n}\nSUMMARY {\nint id PK\nstring timestamp\nstring summary_text\nstring source\nstring category\nstring content_hash\n}\nACTIONLOG {\nint id PK\nstring timestamp\nstring action_name\nstring params\nstring status\nstring result\n}\nMOODLOG {\nint id PK\nstring timestamp\nstring mood_vector\n}\nEXPERIMENTLOG {\nint id PK\nstring timestamp\nstring hypothesis\nstring results\n}\nVERYLONGTERMMEMORY {\nstring memory_id PK\nstring memory_type\ndatetime created_at\ndatetime last_accessed\nfloat importance_score\nfloat strategic_value\nstring compressed_content\nstring metadata_info\n}\nMEMORYPATTERN {\nstring pattern_id PK\nstring pattern_type\nstring pattern_description\nfloat confidence_score\ndatetime discovered_at\nstring source_memory_id FK\n}\nMEMORYCONSOLIDATION {\nstring consolidation_id PK\ndatetime consolidation_date\nstring consolidation_type\nint memories_processed\nint patterns_extracted\nfloat compression_ratio\n}\nSTRATEGICKNOWLEDGE {\nstring knowledge_id PK\nstring knowledge_domain\nstring knowledge_summary\nfloat confidence_level\ndatetime last_updated\nint application_count\n}\nCONSOLIDATIONPATTERN {\nstring consolidation_id PK, FK\nstring pattern_id PK, FK\nfloat extraction_confidence\n}\nPATTERNSTRATEGICKNOWLEDGE {\nstring pattern_id PK, FK\nstring knowledge_id PK, FK\nfloat contribution_weight\n}\nSITUATIONLOG ||--o{ DECISIONLOG : \"has\"\nARTICLE ||--o{ EVENT : \"triggers\"\nSUMMARY ||--o{ EXPERIMENTLOG : \"informs\"\nACTIONLOG ||--o{ SITUATIONLOG : \"generates\"\nMOODLOG ||--o{ SITUATIONLOG : \"influences\"\nVERYLONGTERMMEMORY ||--o{ MEMORYPATTERN : \"contains\"\nMEMORYPATTERN ||--o{ MEMORYCONSOLIDATION : \"extracted_in\"\nMEMORYPATTERN ||--o{ STRATEGICKNOWLEDGE : \"contributes_to\"\nMEMORYCONSOLIDATION ||--o{ CONSOLIDATIONPATTERN : \"has\"\nCONSOLIDATIONPATTERN ||--o{ MEMORYPATTERN : \"links\"\nMEMORYPATTERN ||--o{ PATTERNSTRATEGICKNOWLEDGE : \"links\"\nPATTERNSTRATEGICKNOWLEDGE ||--o{ STRATEGICKNOWLEDGE : \"links\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\n**Diagram sources**\n- [core/vltm_data_models.py](file://c:\\Users\\ASUS\\Documents\\GitHub\\RAVANA\\core\\vltm_data_models.py#L56-L198)\n- [database/vltm_schema.sql](file://c:\\Users\\ASUS\\Documents\\GitHub\\RAVANA\\database\\vltm_schema.sql#L96-L125)\n\n**Section sources**\n- [core/vltm_data_models.py](file://c:\\Users\\ASUS\\Documents\\GitHub\\RAVANA\\core\\vltm_data_models.py#L56-L198)\n- [database/vltm_schema.sql](file://c:\\Users\\ASUS\\Documents\\GitHub\\RAVANA\\database\\vltm_schema.sql#L67-L125)\n\n## Data Access Patterns and ORM Usage\nThe system uses SQLModel as an ORM (Object-Relational Mapper) to interact with the database, providing a clean, Pythonic interface for data operations.\n\n### ORM Configuration\nThe database engine is configured in `engine.py` using SQLAlchemy's create_engine function with the database URL obtained from the configuration system.\n\n```python\nfrom sqlmodel import create_engine, SQLModel\nfrom core.config import Config\n\nengine = create_engine(Config.DATABASE_URL, echo=True)\n\ndef create_db_and_tables():\n    SQLModel.metadata.create_all(engine)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ecreate_db_and_tables()\u003c/code\u003e function initializes the database schema by creating all tables defined in the SQLModel classes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/engine.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTransaction Boundaries\u003c/h3\u003e\n\u003cp\u003eData access follows a consistent pattern using context managers to ensure proper transaction boundaries and resource cleanup. The \u003ccode\u003eDataService\u003c/code\u003e class in \u003ccode\u003edata_service.py\u003c/code\u003e implements methods for saving various types of data with proper transaction management.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef save_action_log(self, action_name: str, params: dict, status: str, result: any):\n    \"\"\"Saves a record of an executed action to the database.\"\"\"\n    with Session(self.engine) as session:\n        action_log = ActionLog(\n            timestamp=datetime.utcnow().isoformat(),\n            action_name=action_name,\n            params=json.dumps(params),\n            status=status,\n            result=json.dumps(result)\n        )\n        session.add(action_log)\n        session.commit()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eKey characteristics of the data access pattern:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEach operation uses a context manager (\u003ccode\u003ewith Session(...) as session\u003c/code\u003e) to ensure the session is properly closed\u003c/li\u003e\n\u003cli\u003eTransactions are committed explicitly with \u003ccode\u003esession.commit()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eJSON serialization is used for complex data structures stored in text fields\u003c/li\u003e\n\u003cli\u003eOperations are atomic and follow the principle of least privilege\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eData Service Implementation\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eDataService\u003c/code\u003e class provides a service layer interface for database operations, abstracting the underlying ORM details from the rest of the application.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKey methods:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efetch_and_save_articles()\u003c/code\u003e: Fetches articles from configured RSS feeds and saves new ones to the database\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edetect_and_save_events()\u003c/code\u003e: Analyzes articles to detect significant events and saves them\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esave_action_log()\u003c/code\u003e: Records system actions\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esave_mood_log()\u003c/code\u003e: Records the system's emotional state\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esave_situation_log()\u003c/code\u003e: Records generated situations\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esave_decision_log()\u003c/code\u003e: Records decisions made by the system\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esave_experiment_log()\u003c/code\u003e: Records experiments and their results\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe service layer ensures consistent data handling and provides a single point of control for database interactions.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003eservices/data_service.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eIndexing Strategy for Performance-Critical Queries\u003c/h2\u003e\n\u003cp\u003eThe system employs a multi-layered approach to optimize performance-critical queries, particularly for memory retrieval operations.\u003c/p\u003e\n\u003ch3\u003eChromaDB for Semantic Memory Retrieval\u003c/h3\u003e\n\u003cp\u003eFor performance-critical memory retrieval operations, the system uses ChromaDB, an embedding database optimized for semantic search. This is implemented in the \u003ccode\u003eepisodic_memory\u003c/code\u003e module.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eKey features:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUses sentence-transformers with the 'all-MiniLM-L6-v2' model to generate 384-dimensional embeddings\u003c/li\u003e\n\u003cli\u003eStores embeddings in a persistent ChromaDB collection with automatic embedding generation\u003c/li\u003e\n\u003cli\u003eSupports similarity-based queries for retrieving relevant memories\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003echroma_collection = chroma_client.get_or_create_collection(\n    name=CHROMA_COLLECTION,\n    embedding_function=sentence_transformer_ef\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eQuery process:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA query text is converted to an embedding vector\u003c/li\u003e\n\u003cli\u003eThe system finds the nearest neighbors in the embedding space\u003c/li\u003e\n\u003cli\u003eResults are returned based on cosine similarity\u003c/li\u003e\n\u003cli\u003eA similarity threshold filters out irrelevant results\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe \u003ccode\u003eget_relevant_memories_api\u003c/code\u003e function implements this retrieval pattern:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef get_relevant_memories_api(request: QueryRequest):\n    results = chroma_collection.query(\n        query_texts=[request.query_text],\n        n_results=request.top_n\n    )\n    \n    # Convert distance to similarity and filter by threshold\n    similarity = 1 - dist\n    if similarity \u003e= request.similarity_threshold:\n        # Include in results\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eVLTM Database Indexing\u003c/h3\u003e\n\u003cp\u003eThe VLTM system implements comprehensive indexing strategies to optimize query performance for very long-term memory operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIndex types:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eB-tree indexes\u003c/strong\u003e: On frequently queried scalar fields like timestamps, memory types, and confidence scores\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGIN indexes\u003c/strong\u003e: On JSONB fields for efficient querying of structured data\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eText search indexes\u003c/strong\u003e: Using tsvector for full-text search capabilities\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eComposite indexes\u003c/strong\u003e: On frequently queried field combinations\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eKey indexes:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eidx_vltm_memory_type\u003c/code\u003e: On memory_type for filtering by memory category\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eidx_vltm_created_at\u003c/code\u003e: On created_at for time-based queries\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eidx_vltm_importance_score\u003c/code\u003e: On importance_score for prioritizing important memories\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eidx_patterns_type\u003c/code\u003e: On pattern_type for filtering by pattern category\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eidx_strategic_domain\u003c/code\u003e: On knowledge_domain for domain-specific queries\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eidx_vltm_metadata_gin\u003c/code\u003e: GIN index on metadata for efficient JSON querying\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eidx_patterns_description_text\u003c/code\u003e: Text search index on pattern descriptions\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/vltm_schema.sql\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003emodules/episodic_memory/memory.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003eservices/memory_service.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eData Lifecycle Policies and Retention\u003c/h2\u003e\n\u003cp\u003eThe system implements automated data lifecycle management through background tasks that handle retention, consolidation, and archival.\u003c/p\u003e\n\u003ch3\u003eKnowledge Compression\u003c/h3\u003e\n\u003cp\u003eThe system runs a periodic knowledge compression task that summarizes recent interactions and creates higher-level abstractions.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConfiguration:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFrequency: Every 24 hours (86,400 seconds)\u003c/li\u003e\n\u003cli\u003eTriggered by: \u003ccode\u003eknowledge_compression_task()\u003c/code\u003e in the main system loop\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eProcess:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eRetrieves recent summaries from the database\u003c/li\u003e\n\u003cli\u003eUses an LLM to compress and synthesize the information\u003c/li\u003e\n\u003cli\u003eCreates new \u003ccode\u003eSummary\u003c/code\u003e records with category \"compression\"\u003c/li\u003e\n\u003cli\u003eUses content hashing to prevent duplication\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def knowledge_compression_task(self):\n    \"\"\"Background task to compress knowledge every 24 hours.\"\"\"\n    while not self._shutdown.is_set():\n        try:\n            summary = await asyncio.to_thread(self.knowledge_service.compress_and_save_knowledge)\n            logger.info(f\"Compressed and saved knowledge summary.\")\n        except Exception as e:\n            logger.error(f\"Error in knowledge compression: {e}\")\n\n        try:\n            await asyncio.sleep(86400)\n        except asyncio.CancelledError:\n            break\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/system.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003eservices/knowledge_service.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eMemory Consolidation\u003c/h3\u003e\n\u003cp\u003eThe system performs periodic memory consolidation to optimize storage and retrieval efficiency.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConfiguration:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFrequency: Every 6 hours (21,600 seconds)\u003c/li\u003e\n\u003cli\u003eTriggered by: \u003ccode\u003ememory_consolidation_task()\u003c/code\u003e in the main system loop\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eProcess:\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSelects a batch of memories for consolidation\u003c/li\u003e\n\u003cli\u003eUses an LLM to analyze, merge, deduplicate, and generalize memories\u003c/li\u003e\n\u003cli\u003eCreates consolidated memories with type 'long-term-consolidated'\u003c/li\u003e\n\u003cli\u003eDeletes the original, redundant memories\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe consolidation process follows these rules:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMerge related memories into comprehensive statements\u003c/li\u003e\n\u003cli\u003eRemove duplicates, keeping the most detailed version\u003c/li\u003e\n\u003cli\u003eGeneralize specific facts into broader categories\u003c/li\u003e\n\u003cli\u003eNever lose critical information\u003c/li\u003e\n\u003cli\u003eNever merge unrelated facts\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003easync def memory_consolidation_task(self):\n    \"\"\"Periodically consolidates memories to optimize retrieval and relevance.\"\"\"\n    while not self._shutdown.is_set():\n        try:\n            logger.info(\"Starting memory consolidation...\")\n            consolidation_result = await self.memory_service.consolidate_memories()\n            logger.info(f\"Memory consolidation finished. Report: {consolidation_result}\")\n        except Exception as e:\n            logger.error(f\"Error during memory consolidation: {e}\", exc_info=True)\n\n        try:\n            await asyncio.sleep(21600)\n        except asyncio.CancelledError:\n            break\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/system.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003emodules/episodic_memory/memory.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eVLTM Retention Policies\u003c/h3\u003e\n\u003cp\u003eThe Very Long-Term Memory system implements configurable retention policies based on memory type and importance.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePolicy configuration:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eStrategic knowledge\u003c/strong\u003e: Permanent retention, compression after 90 days\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCritical failures\u003c/strong\u003e: Permanent retention, compression after 30 days\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSuccessful improvements\u003c/strong\u003e: 2-year retention, compression after 180 days\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCode patterns\u003c/strong\u003e: 1-year retention, compression after 90 days\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eRetention rules:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMemories are automatically compressed based on age and type\u003c/li\u003e\n\u003cli\u003eHigh-importance memories are retained permanently\u003c/li\u003e\n\u003cli\u003eLow-importance memories may be archived or deleted based on policy\u003c/li\u003e\n\u003cli\u003eCompression reduces storage footprint while preserving essential information\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003edatabase/vltm_schema.sql\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eData Security, Encryption, and Backup Procedures\u003c/h2\u003e\n\u003cp\u003eThe system's approach to data security, encryption, and backup is primarily defined by its configuration and deployment environment.\u003c/p\u003e\n\u003ch3\u003eDatabase Configuration\u003c/h3\u003e\n\u003cp\u003eThe database URL is configured through environment variables, allowing for flexible deployment configurations.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass Config:\n    DATABASE_URL = os.environ.get(\"DATABASE_URL\", \"sqlite:///ravana_agi.db\")\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eDefault configuration:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSQLite database file named \u003ccode\u003eravana_agi.db\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eStored in the working directory\u003c/li\u003e\n\u003cli\u003eNo built-in encryption at rest\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSecurity implications:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe default SQLite configuration provides no encryption for data at rest\u003c/li\u003e\n\u003cli\u003eProduction deployments should use environment variables to specify a database URL with appropriate security features\u003c/li\u003e\n\u003cli\u003eSupported databases include PostgreSQL, MySQL, and others that can provide encryption at rest\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eData Protection Measures\u003c/h3\u003e\n\u003cp\u003eThe system implements several data protection measures:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDeduplication with hashing:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUses SHA-256 hashing to identify duplicate content\u003c/li\u003e\n\u003cli\u003eHashes are stored in the \u003ccode\u003econtent_hash\u003c/code\u003e field of the \u003ccode\u003eSummary\u003c/code\u003e table\u003c/li\u003e\n\u003cli\u003ePrevents redundant storage of identical information\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003econtent_hash = hashlib.sha256(content.encode('utf-8')).hexdigest()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNo explicit backup procedures:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe codebase does not contain explicit backup procedures\u003c/li\u003e\n\u003cli\u003eBackup strategy would depend on the underlying database system and deployment environment\u003c/li\u003e\n\u003cli\u003eFor SQLite, backup would involve copying the database file\u003c/li\u003e\n\u003cli\u003eFor server-based databases, standard database backup procedures would apply\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eSection sources\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003ecore/config.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003eservices/knowledge_service.py\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eMigration Strategies for Schema Evolution\u003c/h2\u003e\n\u003cp\u003eThe system's architecture suggests several approaches for handling schema evolution, though explicit migration tools are not implemented in the current codebase.\u003c/p\u003e\n\u003ch3\u003eCurrent State\u003c/h3\u003e\n\u003cp\u003eThe system uses SQLModel's \u003ccode\u003ecreate_all()\u003c/code\u003e method to create tables, which only creates missing tables but does not handle schema changes to existing tables.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef create_db_and_tables():\n    SQLModel.metadata.create_all(engine)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis approach has limitations:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDoes not modify existing columns\u003c/li\u003e\n\u003cli\u003eDoes not add constraints to existing tables\u003c/li\u003e\n\u003cli\u003eDoes not handle data migration between schema versions\u003c/li\u003e\n\u003cli\u003eRisk of data loss or corruption during schema changes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRecommended Migration Strategy\u003c/h3\u003e\n\u003cp\u003eFor production use, the following migration strategy is recommended:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Use Alembic for database migrations:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAlembic is the standard migration tool for SQLAlchemy (which SQLModel is built upon)\u003c/li\u003e\n\u003cli\u003eProvides versioned migration scripts\u003c/li\u003e\n\u003cli\u003eSupports both automated and manual migration generation\u003c/li\u003e\n\u003cli\u003eHandles forward and backward migrations\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e2. Migration process:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a new migration script for each schema change\u003c/li\u003e\n\u003cli\u003eInclude data migration logic when necessary\u003c/li\u003e\n\u003cli\u003eTest migrations on a copy of production data\u003c/li\u003e\n\u003cli\u003eApply migrations in a controlled manner\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e3. Example migration workflow:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Generate migration\nalembic revision --autogenerate -m \"Add mood intensity field\"\n\n# Review and edit migration script\n# Apply migration\nalembic upgrade head\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4. Zero-downtime considerations:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDesign schema changes to be backward compatible\u003c/li\u003e\n\u003cli\u003eUse additive changes when possible (adding columns, not removing)\u003c/li\u003e\n\u003cli\u003eImplement feature flags for new functionality\u003c/li\u003e\n\u003cli\u003eDeploy schema changes separately from application changes when possible\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e5. Data migration best practices:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAlways backup data before migrations\u003c/li\u003e\n\u003cli\u003eTest migrations on representative data sets\u003c/li\u003e\n\u003cli\u003eMonitor application behavior after migrations\u003c/li\u003e\n\u003cli\u003eHave a rollback plan for each migration\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile the current codebase does not implement a formal migration system, adopting Alembic or a similar tool would provide a robust solution for schema evolution.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThe RAVANA AGI system employs a comprehensive database schema designed to support an autonomous artificial intelligence that can process information, make decisions, and evolve over time. The schema captures various aspects of the system's operation, including external inputs (articles), internal states (mood logs), cognitive processes (situations, decisions), and learning mechanisms (summaries, experiments).\u003c/p\u003e\n\u003cp\u003eKey strengths of the current implementation include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eClean separation of concerns through well-defined entities\u003c/li\u003e\n\u003cli\u003eEffective use of JSON fields for flexible data storage\u003c/li\u003e\n\u003cli\u003eIntegration of semantic search through ChromaDB for performance-critical memory retrieval\u003c/li\u003e\n\u003cli\u003eAutomated data lifecycle management through periodic compression and consolidation\u003c/li\u003e\n\u003cli\u003eEnhanced Very Long-Term Memory system with many-to-many relationships between consolidations, patterns, and strategic knowledge\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAreas for improvement include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eImplementing a formal database migration system like Alembic\u003c/li\u003e\n\u003cli\u003eEnhancing data security with encryption at rest\u003c/li\u003e\n\u003cli\u003eEstablishing explicit backup procedures\u003c/li\u003e\n\u003cli\u003ePotentially adding database indexes on frequently queried fields\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe system's architecture demonstrates a sophisticated approach to AGI data management, balancing structured storage with flexible, semantic retrieval mechanisms to support intelligent behavior.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eReferenced Files in This Document\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca\u003edatabase/models.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003edatabase/engine.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003eservices/data_service.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003eservices/knowledge_service.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003ecore/config.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003emodules/episodic_memory/memory.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003eservices/memory_service.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003emodules/knowledge_compression/compressed_memory.py\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003ecore/vltm_data_models.py\u003c/a\u003e - \u003cem\u003eUpdated in recent commit\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca\u003edatabase/vltm_schema.sql\u003c/a\u003e - \u003cem\u003eUpdated in recent commit\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"},"docs":[{"slug":"Action System","title":"Action System"},{"slug":"API Reference","title":"API Reference"},{"slug":"Architecture \u0026 Design","title":"Architecture \u0026 Design"},{"slug":"Configuration","title":"Configuration"},{"slug":"Conversational AI Communication Framework","title":"Conversational AI Communication Framework"},{"slug":"Core System","title":"Core System"},{"slug":"Database Schema","title":"Database Schema"},{"slug":"Decision-Making System","title":"Decision-Making System"},{"slug":"Deployment \u0026 Operations","title":"Deployment \u0026 Operations"},{"slug":"Development Guide","title":"Development Guide"},{"slug":"Emotional Intelligence","title":"Emotional Intelligence"},{"slug":"Enhanced Snake Agent","title":"Enhanced Snake Agent"},{"slug":"Enhanced Snake Agent Architecture","title":"Enhanced Snake Agent Architecture"},{"slug":"Graceful Shutdown","title":"Graceful Shutdown"},{"slug":"LLM Integration","title":"LLM Integration"},{"slug":"Memory Systems","title":"Memory Systems"},{"slug":"Multi-Modal Memory","title":"Multi-Modal Memory"},{"slug":"Project Overview","title":"Project Overview"},{"slug":"Self-Improvement","title":"Self-Improvement"},{"slug":"Services","title":"Services"},{"slug":"Snake Agent Configuration","title":"Snake Agent Configuration"},{"slug":"Specialized Modules-57f9b30b-b165-48d3-8e89-196940d26190","title":"Specialized Modules"},{"slug":"Specialized Modules","title":"Specialized Modules"}]},"__N_SSG":true},"page":"/docs/[slug]","query":{"slug":"Database Schema"},"buildId":"QHWQNiRZOuW15nbk5-ngt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>